<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3D前端开发面试题目解析</title>
    <url>/2020/10/23/3d-interview-problems/</url>
    <content><![CDATA[<html><head></head><body><p><img src="/images/uploads/sites/2/2020/10/QQ20201023-145902@2x.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>在我之前的业务流程中，有幸接触到了3D前端开发的内容，从layaAir、verge到threejs,最终采用了threejs技术去实现了一个3D服装定制的效果。近期，接到了一个专业3D开发团队的面试邀请，虽然发挥的不尽人意，但仍不失为一个很好的面试经历。特将面试问题记录一下。</p>
</blockquote>
<h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><p>1.编写一种算法，若M*N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line">[</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">[</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>解读：二维数组矩阵中，含有0的位置，让此位置整行，整列的值都设置为0，返回修改后的数组数列。 思路：先循环矩阵数列，记录需要清零的行和列，再循环修改数组的元素值。 代码实现如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix=[</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> rowLength=matrix.<span class="property">length</span>,columnLength=matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line"><span class="comment">//记录需要清零的行数和列数</span></span><br><span class="line"><span class="keyword">var</span> tempR=[],tempC=[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;rowLength;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;columnLength;j++){</span><br><span class="line">        <span class="keyword">if</span>(!matrix[i][j]){</span><br><span class="line">            tempR.<span class="title function_">push</span>(i);</span><br><span class="line">            tempC.<span class="title function_">push</span>(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;rowLength;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;columnLength;j++){</span><br><span class="line">        <span class="keyword">if</span>(tempR.<span class="title function_">includes</span>(i)tempC.<span class="title function_">includes</span>(j)){</span><br><span class="line">            matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br><span class="line"><span class="comment">//返回如下</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  [1, 1, 0, 1]</span></span><br><span class="line"><span class="comment">//  [0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">//  [1, 1, 0, 1]</span></span><br><span class="line"><span class="comment">//  [1, 1, 0, 1]</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>添加搜索弹窗页面</title>
    <url>/2020/12/08/add-search-dialog/</url>
    <content><![CDATA[<html><head></head><body><blockquote>
<p>仿照eclipse全局搜索UI 仿照Help-&gt;Report Issue弹出新窗口</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>创建顶部搜索菜单以及搜索子菜单</li>
<li>search选项添加注册事件并触发search弹窗</li>
<li>创建search弹窗页面</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建顶部菜单选项"><a href="#创建顶部菜单选项" class="headerlink" title="创建顶部菜单选项"></a>创建顶部菜单选项</h3><p>根据vscode源码结构分析，找到<code>src\vs\workbench\browser\parts\titlebar\menubarControl.ts</code>文件，新增Search一级菜单选项。 <img src="/images/uploads/sites/2/2020/12/image-20201203162722036.png"> 因为模仿<code>Report Issue</code>菜单选项操作，全局搜索到<code>Report &amp;&amp;Issue</code>字符，<code>&amp;&amp;</code>为助记符，通过观察源码猜测跟国际化，正则匹配有关。结合源码结构分析，定位到<code>src\vs\workbench\electron-sandbox\desktop.contribution.ts</code>，该文件内容符合既需要操作DOM又需要使用electron主进程API的特点。在此文件下添加注册二次菜单源码如下： <img src="/images/uploads/sites/2/2020/12/image-20201204161137916.png"></p>
<h3 id="search选项添加注册事件"><a href="#search选项添加注册事件" class="headerlink" title="search选项添加注册事件"></a>search选项添加注册事件</h3><p>为了借鉴reportIssue菜单的事件方法，全局搜索reportIssue菜单绑定的’workbench.action.openIssueReporter‘ 相关命令。 最终确定内容文件为<code>src\vs\workbench\contrib\issue\electron-browser\issue.contribution.ts</code> 同文件夹下还有<code>src\vs\workbench\contrib\issue\browser\issue.web.contribution.ts</code>文件用于在浏览器端执行。 具体代码如下： <img src="/images/uploads/sites/2/2020/12/image-20201204163241405.png"> 在该文件下添加search命令如下： <img src="/images/uploads/sites/2/2020/12/image-20201204163438550.png"> 补充新增命令所需的同级search变量和方法，定位 accessor.get(IWorkbenchIssueService).openReporter(data);中openReporter方法定义，进入<code>'vs/workbench/contrib/issue/electron-browser/issue</code>文件，接口声明如下： <img src="/images/uploads/sites/2/2020/12/image-20201204164428298.png"> 转入接口实现文件<code>src\vs\workbench\contrib\issue\electron-browser\issueService.ts</code>,并添加<code>openSearch</code>方法。 <img src="/images/uploads/sites/2/2020/12/image-20201204173100749.png"> 注意issueService变量通过@IIssueService进行构造参数注入，转到注入的函数文件为<code>vs/platform/issue/electron-sandbox/issue</code>,实现如下： <img src="/images/uploads/sites/2/2020/12/image-20201204173312770.png"> 可知该接口继承<code>ICommonIssueService</code>,进入<code>ICommonIssueService</code>函数文件<code>vs/platform/issue/common/issue</code>找到相关open方法如下： <img src="/images/uploads/sites/2/2020/12/image-20201204173556708.png"> 添加openSearch方法参数，进入该接口实现文件<code>src\vs\platform\issue\electron-main\issueMainService.ts</code> 添加openSearch方法实现，如下：<img src="/images/uploads/sites/2/2020/12/image-20201204174231567.png"></p>
<h3 id="创建search弹窗页面"><a href="#创建search弹窗页面" class="headerlink" title="创建search弹窗页面"></a>创建search弹窗页面</h3><p>此时已经通过注入依赖完成了渲染页面的生成，参考reportIssue页面加载路径，我们把search弹窗页面添加在<code>vs/code/electron-sandbox/search/search.html</code>目录下。 <img src="/images/uploads/sites/2/2020/12/image-20201207084948120.png"> 引入自定义js文件，在js文件中，使用bootstrop-window.js文件下定义的MonacoBootstrapWindow方法，能够加载引入的ts文件，具体如下： <img src="/images/uploads/sites/2/2020/12/image-20201207085120892.png"> 自定义一个ts文件，可在里面编写交互逻辑。</p>
</body></html>]]></content>
      <categories>
        <category>vscode源码解读</category>
      </categories>
  </entry>
  <entry>
    <title>css像素单位理解</title>
    <url>/2020/10/21/css-pixel-unit/</url>
    <content><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发网页中，css中的px是我们经常使用的一个像素单位，也是我们日常工作过程中需要考虑的有关前端适配的一个问题，那么关于px像素涉及到什么样的适配问题，以及怎样解决，下面我们就从理解前端尺寸的几个相关概念开始。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><p>设备尺寸 设备尺寸是指设备对角线长度</p>
<blockquote>
<p>我们看手机的规格参数时，通常会有屏幕尺寸的参数，单位为英寸，它代表设备屏幕尺寸的对角线长度，1英寸=2.54厘米</p>
</blockquote>
</li>
<li><p>设备像素 设备像素是设备的物理像素，是屏幕成像的最小单位，其尺寸大小是绝对的，可理解为显示器的两个像素点之间的距离。</p>
</li>
<li><p>设备分辨率 屏长的设备像素_屏宽的设备像素 可理解为横向屏幕像素点数_竖向屏幕像素点数</p>
</li>
<li><p>dpi(dots per inch) 像素密度，表示水平或垂直方向没英寸长度的像素数目</p>
</li>
<li><p>ppi(pixels per inch) 像素密度，表示沿对角线每英寸长度的像素数目</p>
</li>
<li><p>设备像素比 可通过window.devicePixelRatio获得</p>
</li>
<li><p>设备独立像素 即css的px像素，为一个抽象概念。又叫逻辑像素。 &gt; 分辨率=设备尺寸_像素密度 &gt; 逻辑像素（px）=设备像素_设备像素比 设备像素为绝对尺寸，设屏幕宽度为1，则设备像素为1/设备分辨率，以上逻辑像素计算可转化为： &gt; 1/横向逻辑像素=1/横向设备分辨率*设备像素比 所以，逻辑像素与设备分辨率与设备像素比有关。</p>
</li>
</ul>
<p>设备分辨率为绝对参数，设备像素比又由什么决定的呢？ 随着科技的发展，屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍。高清屏幕带来的问题就是设备像素愈来愈小，如果没有缩放，网页内容会看起来非常小。 在PC端缩放比例为自定义的，一般是单位逻辑像素=单位设备像素。 对移动端来说，缩放比例的确定还要根据viewport来确定。现在为理解viewport，插入视口的概念。</p>
<blockquote>
<p>视口指的是浏览器的可视区域，其宽度和浏览器窗口的宽度保持一致。在 CSS 标准文档中，视口也被称为初始包含块，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度。 而移动端则较为复杂，它涉及到三个视口：布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）。 移动端为了让网页正常显示，分为布局视口与视觉视口两个独立概念，布局视口即网页内容绘制的区域，默认为980px，视觉视口即设备视口。 为了统一规范，乔布斯提出了理想视口的概念，即布局视口=视觉视口，通过viewport去设置</p>
</blockquote>
<p>在非理想视口的情况，逻辑像素与设备像素无关（待补充） 理想视口，即视口为设备视口，此时的逻辑像素与缩放比例有关，经过实践检验，1px=屏幕宽度的1/375，比较符合PC端的感受，根据iPhone6，放大比例为2即326:2</p>
<blockquote>
<p>参考 <a class="link" href="https://blog.csdn.net/lianfengzhidie/article/details/86663715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160330174919725271731274%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160330174919725271731274&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-86663715.pc_first_rank_v2_rank_v28&amp;utm_term=%E5%83%8F%E7%B4%A0(px)%E5%88%B0%E5%BA%95%E7%BB%9D%E5%AF%B9%E5%8D%95%E4%BD%8D%E8%BF%98%E6%98%AF%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8D&amp;spm=1018.2118.3001.4187" title="像素（px）到底绝对单位还是相对单位">像素（px）到底绝对单位还是相对单位<i class="fas fa-external-link-alt"></i></a> <a class="link" href="https://zhuanlan.zhihu.com/p/59210153" title="css尺寸单位认知">css尺寸单位认知<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>前端页面动画实现方式</title>
    <url>/2020/10/29/front-end-animation-implementation/</url>
    <content><![CDATA[<html><head></head><body><p><img src="/images/uploads/sites/2/2020/10/images.jpeg"></p>
<blockquote>
<p>实现方式： 方式一：css3 transitions属性方法 方式二：css3 animations属性方法 方式三：web animations API</p>
</blockquote>
<h4 id="transitions实现"><a href="#transitions实现" class="headerlink" title="transitions实现"></a>transitions实现</h4><p><strong>基本使用方法</strong></p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>:property duration timing-function</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">*property-过渡属性</span><br><span class="line">duration-过渡时长</span><br><span class="line">timing-function-过渡方法*</span><br></pre></td></tr></tbody></table></figure>

<p><strong>平滑过渡多个属性</strong> 使用’,’分割多个过渡属性，示例如下：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.transitions</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#a9ce07</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>) <span class="built_in">translate</span>(<span class="number">80px</span>, <span class="number">100px</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">   ** <span class="attribute">transition</span>: background-color <span class="number">1s</span> linear, color <span class="number">1s</span> linear, transform <span class="number">1s</span> linear; **</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transitions</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00ff00</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>) <span class="built_in">translate</span>(<span class="number">0</span>, <span class="number">0</span>) <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="animations实现"><a href="#animations实现" class="headerlink" title="animations实现"></a>animations实现</h4><p>不同于transitions只能通过指定属性开始值与结束值的动画实现，animations动画功能引入了关键帧的概念，通过多个关键帧可以实现更为复杂的动画效果。 <strong>使用示例</strong></p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> mycolor {</span><br><span class="line">    <span class="number">0%</span> {</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#a9ce07</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="number">40%</span> {</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="number">70%</span> {</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#ffff00</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="number">100%</span> {</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#0000ff</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animations</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">    <span class="attribute">animation</span>: mycolor <span class="number">1s</span> linear;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例说明： （1）先编写关键帧集合，其中<code>mycolor</code>为关键帧集合名称 （2）关键帧代码如下</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">40%</span>{</span><br><span class="line">    样式代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中40%表示该帧处于动画工程中的40%处,括号内部书写关键帧需要改变的样式代码。 （3）创建好关键帧集合后，在元素的样式中通过animation属性使用该关键帧集合。 <strong>animation相关属性介绍</strong> animation-name：指定关键帧集合名称 animation-duration：动画所花费的时长 animation-timing-function：动画方法 animation-delay：动画延迟时间 animation-iteration-count：动画执行次数 animation-direction：动画执行方向 <strong>一行样式书写方式如下</strong></p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>:name duration ti ming-function delay iteration-count-diretion;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Web-Animations-API"><a href="#Web-Animations-API" class="headerlink" title="Web Animations API"></a>Web Animations API</h4><p>web animations api是animations和JavaScript的结合体，可以使用JavaScript控制元素，具有和css一样的性能。 <strong>使用方法</strong> （1）定义关键帧</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keyframes=[</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">transform</span>:<span class="string">'translateX(0px) translateY(0px)'</span></span><br><span class="line">    },{</span><br><span class="line">        <span class="attr">transform</span>:<span class="string">'translateX(300px) translateY(0px)'</span></span><br><span class="line">    },{</span><br><span class="line">        <span class="attr">transform</span>:<span class="string">'translateX(300px) translateY(300px)'</span></span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>说明： web Animations API 默认平均分配动画进程，若需显示定义某个关键帧的出现时刻，需要用到一个<code>offset</code>属性，属性值为一个0-1的小数点值，示例如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">transform</span>:<span class="string">'translateX(0px) translateY(0px)'</span>,</span><br><span class="line">        <span class="attr">offset</span>:<span class="number">0.2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>若关键帧数组只有一个关键帧对象，浏览器将抛出一个NotSupportedErrorcuowu （2）设置动画相关选项，示例如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set={</span><br><span class="line">    <span class="attr">duration</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="attr">iterations</span>:<span class="title class_">Infinity</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>其他相关选项</strong> id-动画标识符 delay-动画延迟时间 direction-动画执行方向 duration-动画花费时长 easing-指定动画方法 iterations-动画执行次数，可设置Infinity（无限次） （3）js执行动画 使用dom对象的animate方法执行动画，示例如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">elem.<span class="title function_">animate</span>(keyFrames,set)</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>语法高亮指南</title>
    <url>/2022/12/06/syntax-highlight-guide/</url>
    <content><![CDATA[<html><head></head><body><h1 id="语法高亮指南"><a href="#语法高亮指南" class="headerlink" title="语法高亮指南"></a>语法高亮指南</h1><p>语法高亮决定了在Visual Studio 代码编辑器中显示的源代码的颜色和风格。 它负责为 <code>if</code> 或 <code>for</code> 着色以区别于字符串、注释和变量名等其他JavaScript关键字。</p>
<p>语法高亮由两部分组成：</p>
<ul>
<li><a href="#tokenization">令牌化</a>: 将文本分解为令牌列表</li>
<li><a href="#theming">主题化</a>: 使用主题或用户设置将令牌映射到特定颜色和样式</li>
</ul>
<p>在深入了解细节之前， 一个良好的开端是使用 <a href="#scope-inspector">范围检查器</a> 工具来探索源文件中存在什么样的令牌以及它们匹配的主题规则。 要看到语义和语法令牌，请在TypeScript 文件上使用一个内置的主题 (例如，Dark+)。</p>
<h2 id="令牌化"><a href="#令牌化" class="headerlink" title="令牌化"></a>令牌化</h2><p>文本的令牌化就是将文本分解为段，并用标记类型对每个段进行分类。</p>
<p>VS Code的令牌华引擎由<a class="link" href="https://macromates.com/manual/en/language_grammars">TextMate 语法<i class="fas fa-external-link-alt"></i></a>驱动。 TextMate 语法是一个结构化的正则表达式集，作为插件(XML) 或JSON文件写成的。 VS Code扩展可通过 <code>语法</code> 贡献点贡献语法。</p>
<p>TextMate令牌化引擎与渲染器运行在相同的进程中，令牌随着用户类型的变化而更新。 令牌用于语法高亮，但也用于将源代码划分为注释、字符串、正则表达式区域。</p>
<p>从版本1.43开始，VS 代码也允许扩展通过 <a href="/api/references/vscode-api#DocumentSemanticTokensProvider">语义令牌提供商</a> 提供令牌化。 语义提供者通常由语言服务器实现，这些语言服务器对源文件有更深的了解，并且可以在项目中解析符号。 例如，一个常量变量名可以在整个项目中使用常量高亮来呈现，而不仅仅是在其声明的地方。</p>
<p>基于语义令牌的高亮被视为基于 TextMate 的语法高亮的补充。 语义高亮显示在语法高亮上。 由于语言服务器可能需要一段时间来加载和分析一个项目，语义标记高亮显示可能会在短时间延迟后出现。</p>
<p>这篇文章着重于基于 TextMate 的令牌化。 语义令牌化和主题化在 <a href="semantic-highlight-guide">语义高亮指南</a> 中进行了解释。</p>
<h3 id="TextMate-语法"><a href="#TextMate-语法" class="headerlink" title="TextMate 语法"></a>TextMate 语法</h3><p>VS Code使用 <a class="link" href="https://macromates.com/manual/en/language_grammars">TextMate 语法<i class="fas fa-external-link-alt"></i></a> 作为语法令牌化引擎。 TextMate 编辑器创造以来， 由于大量的语言包被被开源社区创建和维护，许多其他的编辑器和IDE都采用了这些准则。</p>
<p>TextMate 语法依靠 <a class="link" href="https://macromates.com/manual/en/regular_expressions">Oniguruma 正则表达式<i class="fas fa-external-link-alt"></i></a> 并且通常都是作为插件或 JSON 编写的。 您可以在<a class="link" href="https://www.apeth.com/nonblog/stories/textmatebundle.html">这里<i class="fas fa-external-link-alt"></i></a>找到 TextMate 语法 很好的简介， 并且你可以看看现有的 TextMate 语法来更多地了解它们是如何工作的。</p>
<h3 id="TextMate-令牌和范围"><a href="#TextMate-令牌和范围" class="headerlink" title="TextMate 令牌和范围"></a>TextMate 令牌和范围</h3><p>令牌是一个或多个字符，是同一个程序元素的一部分。 示例令牌包括操作符，如 <code>+</code> 和<code>*</code>, 变量名如 <code>myVar</code>, 或字符串如 <code>"my string"</code>。</p>
<p>每个令牌都与定义令牌上下文的范围相关联。 作用域是一个点分隔的标识符列表，用于指定当前标记的上下文。 例如，JavaScript中的 <code>+</code> 操作符作用域为 <code>keyword.operator.arithmetic.js</code>。</p>
<p>主题将作用域映射到颜色和样式以提供语法高亮。 TextMate为许多主题目标提供了<a class="link" href="https://macromates.com/manual/en/language_grammars">常用作用域列表<i class="fas fa-external-link-alt"></i></a> 。 为了使您的语法得到尽可能广泛的支持，请尝试在现有范围基础上进一步发展，而不是确定新的范围。</p>
<p>作用域嵌套，以便每个令牌也与父作用域列表相关联。 下面的示例使用<a href="#scope-inspector">范围检查器</a>在一个简单的JavaScript函数中显示 <code>+</code>操作符的范围层次结构。 最具体的范围列在顶部，较一般的父范围列于下面：</p>
<p><img src="/_posts/images/syntax-highlighting/scopes.png" alt="syntax highlighting scopes"></p>
<p>父范围信息也用于主题化。 当主题以一个作用域为目标时，所有带有该父作用域的令牌都将被着色，除非主题还为它们各自的作用域提供更具体的着色。</p>
<h3 id="贡献基本语法"><a href="#贡献基本语法" class="headerlink" title="贡献基本语法"></a>贡献基本语法</h3><p>VS Code支持 json TextMate 语法。 这些都是通过 <code>语法</code> <a href="/api/references/contribution-points">贡献点</a> 贡献的。</p>
<p>每个语法贡献具体指：语法所适用语言的标识符。 语法标记的顶级范围名称和语法文件的相对路径。 下面的例子展示了一个虚构的<code>abc</code>语言的语法贡献</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"contributes"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"languages"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"abc"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"extensions"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">".abc"</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"grammars"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"language"</span><span class="punctuation">:</span> <span class="string">"abc"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"source.abc"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"path"</span><span class="punctuation">:</span> <span class="string">"./syntaxes/abc.tmGrammar.json"</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>语法文件本身由顶层规则组成。 这通常分为列出程序顶层元素的 <code>patterns</code> 部分和定义每个元素的 <code>repository</code>。 语法中的其他规则可以通过 <code>repository</code> 使用 <code>{ "include": "#id" }</code>来引用元素。</p>
<p>示例 <code>abc</code> 语法标记字母 <code>a</code>, <code>b</code>, 和 <code>c</code> 作为关键词和括号内嵌套表达式。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"source.abc"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"patterns"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span> <span class="attr">"include"</span><span class="punctuation">:</span> <span class="string">"#expression"</span> <span class="punctuation">}</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"repository"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"expression"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"patterns"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span> <span class="attr">"include"</span><span class="punctuation">:</span> <span class="string">"#letter"</span> <span class="punctuation">}</span><span class="punctuation">,</span> <span class="punctuation">{</span> <span class="attr">"include"</span><span class="punctuation">:</span> <span class="string">"#paren-expression"</span> <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"letter"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"match"</span><span class="punctuation">:</span> <span class="string">"a|b|c"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"keyword.letter"</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"paren-expression"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"begin"</span><span class="punctuation">:</span> <span class="string">"\\("</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"end"</span><span class="punctuation">:</span> <span class="string">"\\)"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"beginCaptures"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"0"</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"punctuation.paren.open"</span> <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"endCaptures"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"0"</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"punctuation.paren.close"</span> <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"expression.group"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"patterns"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span> <span class="attr">"include"</span><span class="punctuation">:</span> <span class="string">"#expression"</span> <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>语法引擎将尝试对文档中的所有文本依次应用 <code>表达式</code>规则。 对于一个简单的程序，例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a</span><br><span class="line">(</span><br><span class="line">    b</span><br><span class="line">)</span><br><span class="line">x</span><br><span class="line">(</span><br><span class="line">    (</span><br><span class="line">        c</span><br><span class="line">        xyz</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">a</span><br></pre></td></tr></tbody></table></figure>

<p>示例语法生成以下作用域(从左到右从最特定的作用域到最不特定的作用域列出)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a               keyword.letter, source.abc</span><br><span class="line">(               punctuation.paren.open, expression.group, source.abc</span><br><span class="line">    b           keyword.letter, expression.group, source.abc</span><br><span class="line">)               punctuation.paren.close, expression.group, source.abc</span><br><span class="line">x               source.abc</span><br><span class="line">(               punctuation.paren.open, expression.group, source.abc</span><br><span class="line">    (           punctuation.paren.open, expression.group, expression.group, source.abc</span><br><span class="line">        c       keyword.letter, expression.group, expression.group, source.abc</span><br><span class="line">        xyz     expression.group, expression.group, source.abc</span><br><span class="line">    )           punctuation.paren.close, expression.group, expression.group, source.abc</span><br><span class="line">)               punctuation.paren.close, expression.group, source.abc</span><br><span class="line">(               punctuation.paren.open, expression.group, source.abc</span><br><span class="line">a               keyword.letter, expression.group, source.abc</span><br></pre></td></tr></tbody></table></figure>

<p>注意，当前作用域中包含了不被任何规则匹配的文本，例如字符串<code>xyz</code>。 文件末尾的最后一个括号是<code>expression.group</code>的一部分，即使结束规则不匹配，因为在结束规则之前找到了文档结束。</p>
<h3 id="嵌入式语言（Embedded-languages）"><a href="#嵌入式语言（Embedded-languages）" class="headerlink" title="嵌入式语言（Embedded languages）"></a>嵌入式语言（Embedded languages）</h3><p>如果您的语法在父语言中包含嵌入式语言，例如HTML中的CSS样式块，你可以使用<code>embeddedLanguages</code>贡献点告诉VS Code将嵌入式语言与父语言区别对待。 这确保括号匹配、注释和其他基本语言特性在嵌入式语言中按预期工作。</p>
<p><code>embeddedLanguages</code>贡献点将嵌入式语言中的作用域映射到顶级语言作用域。 在下面的例子中，<code>meta.embedded.block.javascript</code>作用域中的任何令牌都将被视为JavaScript内容：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"contributes"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"grammars"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"path"</span><span class="punctuation">:</span> <span class="string">"./syntaxes/abc.tmLanguage.json"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"source.abc"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"embeddedLanguages"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"meta.embedded.block.javascript"</span><span class="punctuation">:</span> <span class="string">"javascript"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在，如果你试图评论代码或触发代码片段在标记为 <code>meta.embeded.block.javascript</code>的令牌集合中, 他们将得到正确的 <code>//</code> JavaScript 风格的评论和正确的 JavaScript 代码片段。</p>
<h3 id="开发新的语法扩展"><a href="#开发新的语法扩展" class="headerlink" title="开发新的语法扩展"></a>开发新的语法扩展</h3><p>快速创建一个新的语法扩展， 使用 <a href="/api/get-started/your-first-extension">VS Code’s Yeoman templates</a> 来运行 <code>yo code</code> 并选择 <code>New Language</code> 选项：</p>
<p><img src="/_posts/images/syntax-highlighting/yo-new-language.png" alt="Selecting the 'new language' template in 'yo code'"></p>
<p>Yeoman将通过一些基本问题带你去搭建新的扩展。 创建新语法的重要问题是：</p>
<ul>
<li><code>Language id</code> - 您的语言的唯一标识符。</li>
<li><code>Language name</code> - 为您的语言提供一个人类可读的名称。</li>
<li><code>Scope names</code> - 语法的根TextMate作用域名称.</li>
</ul>
<p><img src="/_posts/images/syntax-highlighting/yo-new-language-questions.png" alt="Filling in the 'new language' questions"></p>
<p>生成器假设您想要为该语言定义一种新语言和一种新语法。 如果您正在为现有语言创建语法，只需用目标语言的信息填充这些语法，并确保删除生成的<code>package.json</code>中的<code>languages</code>贡献点。</p>
<p>在回答所有问题后，Yeoman将创建一个结构性的新扩展：</p>
<p><img src="/_posts/images/syntax-highlighting/generated-new-language-extension.png" alt="A new language extension"></p>
<p>记住，如果你要为VS Code已经知道的语言贡献语法，一定要删除生成的<code>package.json</code>中的<code>languages</code>贡献点。</p>
<h4 id="转换现有的-TextMate-语法"><a href="#转换现有的-TextMate-语法" class="headerlink" title="转换现有的 TextMate 语法"></a>转换现有的 TextMate 语法</h4><p><code>yo code</code> 也可以帮助将现有的 TextMate 语法转换为 VS 代码扩展。 同样，首先运行<code>yo code</code>并选择<code>语言扩展</code>。 当被问到一个现有的语法文件时，给它一个<code>.tmLanguage</code>或<code>.json TextMate</code>语法文件的完整路径：</p>
<p><img src="/_posts/images/syntax-highlighting/yo-convert.png" alt="Converting an existing TextMate grammar"></p>
<h4 id="使用-YAML-书写语法"><a href="#使用-YAML-书写语法" class="headerlink" title="使用 YAML 书写语法"></a>使用 YAML 书写语法</h4><p>随着语法变得越来越复杂，将其作为json来理解和维护可能会变得困难。 如果您发现自己正在编写复杂的正则表达式，或者需要添加注释来解释语法的各个方面，那么可以考虑使用yaml来定义语法。</p>
<p>Yaml语法具有与基于json的语法完全相同的结构，但允许您使用Yaml更简洁的语法，以及多行字符串和注释等特性。</p>
<p><img src="/_posts/images/syntax-highlighting/yaml-grammar.png" alt="A yaml grammar using multiline strings and comments"></p>
<p>VS Code只能加载json语法，所以基于yaml的语法必须转换成json。 <code>js-yaml</code>包和命令行工具使这变得很容易。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将js-yaml安装为扩展中的开发依赖项</span></span><br><span class="line">$ npm install js-yaml --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命令行工具将yaml语法转换为json</span></span><br><span class="line">$ npx js-yaml syntaxes/abc.tmLanguage.yaml &gt; syntaxes/abc.tmLanguage.json</span><br></pre></td></tr></tbody></table></figure>

<h3 id="注入语法（Injection-grammars）"><a href="#注入语法（Injection-grammars）" class="headerlink" title="注入语法（Injection grammars）"></a>注入语法（Injection grammars）</h3><p>注入语法允许您扩展现有的语法。 注入语法是一种常规的TextMate语法，它被注入到现有语法中的特定范围中。 注入语法的实例应用：</p>
<ul>
<li>在评论中突出TODO等关键字。</li>
<li>在现有语法中添加更具体的范围信息。</li>
<li>为Markdown围栏代码块添加新语言的高亮显示。</li>
</ul>
<h4 id="创建一个基本的注入语法"><a href="#创建一个基本的注入语法" class="headerlink" title="创建一个基本的注入语法"></a>创建一个基本的注入语法</h4><p>就像常规语法一样，注入语法通过 <code>package.json</code> 所提供。 然而，注入语法不指定语言，而是使用<code>injectTo</code>来指定要将语法注入到其中的目标语言作用域列表。</p>
<p>对于本例，我们将创建一个简单的注入语法，将<code>TODO</code>突出显示为JavaScript注释中的关键字。 为了在JavaScript文件中应用我们的注入语法，我们在<code>injectTo</code>中使用<code>source.js</code>目标语言作用域：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"contributes"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"grammars"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"path"</span><span class="punctuation">:</span> <span class="string">"./syntaxes/injection.json"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"todo-comment.injection"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"injectTo"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"source.js"</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>除了最顶层的<code>injectionSelector</code>条目外，语法本身是标准的TextMate语法。 <code>injectionSelector</code>是一个范围选择器，它指定应该在哪个范围中应用注入的语法。 在我们的例子中，我们想要在所有的<code>//</code>注释凸显单词<code>TODO</code>。 使用<code>scope inspector</code>，我们发现JavaScript的双斜杠注释具有<code>comment.line.double-slash</code>范围，所以我们的注入选择器是<code>L:comment.line.double-slash</code>：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"todo-comment.injection"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"injectionSelector"</span><span class="punctuation">:</span> <span class="string">"L:comment.line.double-slash"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"patterns"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"include"</span><span class="punctuation">:</span> <span class="string">"#todo-keyword"</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"repository"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"todo-keyword"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"match"</span><span class="punctuation">:</span> <span class="string">"TODO"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"keyword.todo"</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>注入选择器中的 <code>L：</code> 意味着注入被添加到现有语法规则的左边。 这基本上意味着我们注入的语法规则将在任何现有语法规则之前应用。</p>
<h4 id="嵌入式语言（Embedded-languages）-1"><a href="#嵌入式语言（Embedded-languages）-1" class="headerlink" title="嵌入式语言（Embedded languages）"></a>嵌入式语言（Embedded languages）</h4><p>注入语法也可以为父级语法提供嵌入语言。 就像普通语法一样，注入语法可以使用<code>embeddedLanguages</code>将范围从嵌入式语言映射到顶级语言范围。</p>
<p>例如，在JavaScript字符串中突出显示SQL查询的扩展可以使用<code>embeddedLanguages</code>来确保标记为<code>meta.embedded.inline.sql</code>的字符串中的所有令牌都被视为SQL，以实现基本的语言功能，如括号匹配和代码片段选择。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"contributes"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"grammars"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"path"</span><span class="punctuation">:</span> <span class="string">"./syntaxes/injection.json"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"sql-string.injection"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"injectTo"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"source.js"</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"embeddedLanguages"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"meta.embedded.inline.sql"</span><span class="punctuation">:</span> <span class="string">"sql"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="令牌类型和嵌入语言"><a href="#令牌类型和嵌入语言" class="headerlink" title="令牌类型和嵌入语言"></a>令牌类型和嵌入语言</h4><p>对于注入语言嵌入式语言还有一个额外的复杂性: 默认情况下，VS Code将字符串中的所有标记视为字符串内容，将带有注释的所有标记视为标记内容。 由于括号匹配和自动关闭对等功能在字符串和注释中被禁用，如果嵌入式语言出现在字符串或注释中，这些嵌入式语言中的功能也将被禁用。</p>
<p>要覆盖此行为，可以使用<code>meta.embedded.*</code>范围重置VS Code标记为字符串或注释内容。 将嵌入式语言封装在<code>meta.embedded.*</code>范围中是个好主意，以确保VS Code正确的处理嵌入式语言。</p>
<p>如果您不能添加 <code>meta.embeded.</code> 范围到您的语法中， 您也可以在语法的贡献点中使用 <code>tokenTypes</code> 将特定范围映射到内容模式。 下面的 <code>tokenTypes</code> 部分确保了 <code>my.sql.template.string</code> 范围中的任何内容被当作源代码处理：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"contributes"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"grammars"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"path"</span><span class="punctuation">:</span> <span class="string">"./syntaxes/injection.json"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"scopeName"</span><span class="punctuation">:</span> <span class="string">"sql-string.injection"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"injectTo"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"source.js"</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"embeddedLanguages"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"my.sql.template.string"</span><span class="punctuation">:</span> <span class="string">"sql"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"tokenTypes"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"my.sql.template.string"</span><span class="punctuation">:</span> <span class="string">"other"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题化是为令牌分配颜色和样式 主题规则在颜色主题中指定，但用户可以在用户设置中自定义主题规则。</p>
<p>TextMate 主题规则在 <code>tokenColors</code> 中定义，并且与普通的 TextMate 主题具有相同的语法。 每个规则都定义一个 TextMate 范围选择器和由此产生的颜色和风格。</p>
<p>在评估令牌的颜色和样式时，将根据规则的选择器匹配当前令牌的作用域，为每个样式属性(前景色、粗体、斜体、下划线) 找到最具体的规则。</p>
<p><a href="/api/extension-guides/color-theme#syntax-colors">颜色主题指南</a> 描述了如何创建一个颜色主题。 语义令牌的主题在 <a href="semantic-highlight-guide#theming">语义高亮指南</a> 中作了解释。</p>
<h2 id="范围检查器（Scope-inspector）"><a href="#范围检查器（Scope-inspector）" class="headerlink" title="范围检查器（Scope inspector）"></a>范围检查器（Scope inspector）</h2><p>VS Code的内置范围检查工具有助于调试语法和语义标记。 它在文件中当前位置显示令牌和语义语义令牌的范围，以及关于应用于该令牌的主题规则的元数据。</p>
<p>在命令面板使用<code>Developer: Inspect Editor Tokens and Scopes</code>或<code>create a keybinding</code>命令可触发范围检查器：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"key"</span><span class="punctuation">:</span> <span class="string">"cmd+alt+shift+i"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"command"</span><span class="punctuation">:</span> <span class="string">"editor.action.inspectTMScopes"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/_posts/images/syntax-highlighting/scope-inspector.png" alt="scope inspector"></p>
<p>范围检查器显示以下信息：</p>
<ol>
<li>当前令牌。</li>
<li>关于令牌的元数据和关于其计算外观的信息。 如果您使用的是嵌入式语言，那么这里的重要条目是<code>language</code>和<code>token type</code>。</li>
<li>当语义令牌提供程序可用于当前语言且当前主题支持语义高亮显示时，将显示语义令牌部分。 它显示了当前的语义标记令牌和修饰符，以及与语义令牌类型和修饰符匹配的主题规则。</li>
<li>TextMate部分显示了当前TextMate令牌的作用域列表，最具体的作用域位于顶部。 它还显示与范围相匹配的最具体主题规则。 这只显示负责令牌当前样式的主题规则，不显示被覆盖的规则。 如果存在语义令牌，则仅当主题规则与匹配语义令牌的规则不同时才显示主题规则。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>--vscode docs</category>
      </categories>
  </entry>
  <entry>
    <title>vscode启动时嵌入登录页面</title>
    <url>/2020/12/08/vscode-insert-login/</url>
    <content><![CDATA[<html><head></head><body><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>基于vscode源码实现一个登陆页面。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据<a class="link" href="https://cloud.tencent.com/developer/article/1454979" title="启动流程">启动流程<i class="fas fa-external-link-alt"></i></a>，在启动之前判断是否需要登陆，若需要弹出一个登陆页面，登陆验证成功后进入应用，否则弹出错误提示，若验证超过三次退出应用。 1.找到合适的启动程序位置。在启动应用之前，判断是否需要登陆。 2.在执行启动程序位置编写登陆程序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="确定登陆逻辑合适的编写位置"><a href="#确定登陆逻辑合适的编写位置" class="headerlink" title="确定登陆逻辑合适的编写位置"></a>确定登陆逻辑合适的编写位置</h3><p>在确定登陆逻辑位置之前，先复习下vscode源码的启动流程：</p>
<ul>
<li>入口是 src/main.js</li>
<li>主进程（Main Process） 的实际调用路径是: <code>main.js -&gt; vs/code/electron-main/main.ts -&gt; vs/code/electron-main/window.ts</code> 在 <code>window.ts</code> 启动了一个<code>BrowserWindow</code> 加载了 <code>vs/code/electron-browser/workbench/workbench.html</code></li>
<li>渲染进程（Renderer Process）的实际路径是： <code>vs/code/electron-browser/workbench/workbench.html -&gt; vs/code/electron-browser/workbench/workbench.js</code></li>
</ul>
<p>我们要做的是，在程序主进程渲染之前，判断并弹出一个登陆窗口。需要使用到electron的API，结合vscode源码的环境划分，我们需要把逻辑写在vs/code/electron-main/main.ts文件下。</p>
<h3 id="登陆逻辑实现"><a href="#登陆逻辑实现" class="headerlink" title="登陆逻辑实现"></a>登陆逻辑实现</h3><p>观察ts文件代码： <img src="/images/uploads/sites/2/2020/12/image-20201207195618170.png"> 发现主要代码写在CodeMain类里。 首先贴上我的源码实现：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CodeMain</span> {</span><br><span class="line">    <span class="title function_">main</span>(loginWindow?:<span class="title class_">BrowserWindow</span>):<span class="built_in">void</span> {</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">token</span>) {</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">createWindow</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Launch</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">startup</span>(args).<span class="title function_">then</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">                <span class="keyword">if</span>(loginWindow){</span><br><span class="line">                    loginWindow.<span class="title function_">close</span>();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> token = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//创建登录窗口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">createWindow</span>(): <span class="built_in">void</span> {</span><br><span class="line">        <span class="comment">//子窗口</span></span><br><span class="line">        <span class="keyword">let</span> loginWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>({</span><br><span class="line">            <span class="attr">width</span>: <span class="number">600</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">800</span>,</span><br><span class="line">            <span class="attr">frame</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">webPreferences</span>: {</span><br><span class="line">                <span class="attr">nodeIntegration</span>: <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">//加载页面</span></span><br><span class="line">        loginWindow.<span class="title function_">loadFile</span>(<span class="string">'src/vs/code/browser/workbench/login.html'</span>);</span><br><span class="line">        ipcMain.<span class="title function_">on</span>(<span class="string">'exit'</span>, <span class="keyword">function</span> (<span class="params">event</span>) {</span><br><span class="line">            loginWindow.<span class="title function_">close</span>();</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">//设置一个变量记录登录次数</span></span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从页面接收用户输入的账号密码</span></span><br><span class="line">        ipcMain.<span class="title function_">on</span>(<span class="string">'login'</span>, <span class="function">(<span class="params">event, username, password</span>) =&gt;</span> { <span class="comment">//如果没有数据需要传，可以不写参数</span></span><br><span class="line">            <span class="comment">//判断账号密码</span></span><br><span class="line">            <span class="keyword">if</span> (username === <span class="string">'123'</span> &amp;&amp; password === <span class="string">'123'</span>) {</span><br><span class="line">                <span class="comment">//登陆成功</span></span><br><span class="line">                <span class="comment">//隐藏登录窗口(loginWindow.close();无法启动主窗口)</span></span><br><span class="line">                dialog.<span class="title function_">showMessageBox</span>({</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">'info'</span>,</span><br><span class="line">                    <span class="attr">title</span>: <span class="string">'登录成功'</span>,</span><br><span class="line">                    <span class="attr">message</span>: <span class="string">'登录成功'</span>,</span><br><span class="line">                    <span class="attr">buttons</span>:[<span class="string">'进入应用'</span>]</span><br><span class="line">                }).<span class="title function_">then</span>(<span class="function">()=&gt;</span>{</span><br><span class="line">                    <span class="comment">//更改标签，调用主窗口</span></span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">token</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// Main Startup</span></span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">main</span>(loginWindow);</span><br><span class="line">                });</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//登录次数加 1</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//超过三次，窗口关闭</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt;= <span class="number">3</span>) {</span><br><span class="line">                    <span class="comment">//返回三次登录信息</span></span><br><span class="line">                    <span class="keyword">let</span> loginMessage = <span class="string">'3次登陆失败，窗口将在1秒后关闭'</span>;</span><br><span class="line">                    loginWindow.<span class="property">webContents</span>.<span class="title function_">send</span>(<span class="string">'loginMessage'</span>, loginMessage);</span><br><span class="line">                    <span class="comment">//延时三秒关闭窗口</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">                        loginWindow.<span class="title function_">close</span>();</span><br><span class="line">                    }, <span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//登陆失败</span></span><br><span class="line">                    <span class="comment">//返回失败信息</span></span><br><span class="line">                    <span class="keyword">let</span> loginMessage = <span class="string">'登陆失败！登录次数：'</span> + count + <span class="string">'次，共有3次！'</span>;</span><br><span class="line">                    <span class="comment">//向窗口发送登陆失败消息</span></span><br><span class="line">                    loginWindow.<span class="property">webContents</span>.<span class="title function_">send</span>(<span class="string">'loginMessage'</span>, loginMessage);</span><br><span class="line">                    <span class="comment">//刷新窗口，重新登陆</span></span><br><span class="line">                    loginWindow.<span class="title function_">reload</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码解析： 1.声明一个验证变量：token 2.创建一个创建登陆窗口的方法：createWindow，内部实现使用了electron主进程api，BrowserWindow、IPC等。 3.登陆成功时需要先等待vscode主进程启动成功才能把loginWindow窗口关闭，否则会导致程序退出。 4.登陆页面的位置也是依据源码环境划分原则，放置在src/vs/code/browser/workbench目录下。</p>
<h3 id="登陆优化计划"><a href="#登陆优化计划" class="headerlink" title="登陆优化计划"></a>登陆优化计划</h3><p>在页面运行成功后，添加login菜单选项，触发调起登陆页面。</p>
</body></html>]]></content>
      <categories>
        <category>vscode源码解读</category>
      </categories>
  </entry>
  <entry>
    <title>vscode源码初识（一）</title>
    <url>/2020/11/11/vscode-meet-1/</url>
    <content><![CDATA[<html><head></head><body><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><em>公司规划要做一个IDE，经过前期产品调研，确认以vscode源码为研究对象，基于vscode开发一款新的IDE产品，所以我有较长的时间需要啃懂vscode相关的技术实现，由于前期对vscode涉及的相关技术，如typescript、electron、nodejs缺乏系统了解，也无相关开发经验，因此读懂vscode源码对我来说是个大工程，希望通过博客能记录学习过程、梳理相关概念、总结技术难点，帮助我更好的上手IDE开发</em></p>
<blockquote>
<p>本系列前期仅能对vscode源码进行一些相对浅显的理解，后期随着项目深入，将由浅入深的分享一些开发细节。</p>
</blockquote>
<h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><p>前期研究目标</p>
<blockquote>
<ol>
<li>启动vscode源码</li>
<li>了解vscode源码基本结构</li>
<li>了解vscode模块与模块之前的运作</li>
<li>了解导航栏的基本操作</li>
</ol>
</blockquote>
<h2 id="vscode源码运行"><a href="#vscode源码运行" class="headerlink" title="vscode源码运行"></a>vscode源码运行</h2><p>不管有没有vscode相关技术，首先需要先认识一下vscode源码的基本结构和启动流程，便于在随后的学习过程中有个侧重点。 关于启动vscode源码，网上有很多参考教程，我这里大致做一个流程总结。具体参考<a class="link" href="https://www.cnblogs.com/liulun/p/11037537.html" title="在这里">在这里<i class="fas fa-external-link-alt"></i></a>。</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">安装git，nodejs和yarn</span><br><span class="line">安装Python27，3.x版本的不行，确保它在你的环境变量里；</span><br><span class="line">安装gulp</span><br><span class="line">npm install --global gulp-cli</span><br><span class="line"></span><br><span class="line">安装windows build tools：</span><br><span class="line">npm install --global windows-build-tools --2017</span><br><span class="line"></span><br><span class="line">安装node-gyp</span><br><span class="line">npm install -g node-gyp</span><br><span class="line"></span><br><span class="line">**用管理员的方式打开powershell**，不是管理员身份不行</span><br><span class="line">在源码根目录下执行：</span><br><span class="line">yarn 安装相关包</span><br><span class="line">yarn watch 编译项目</span><br><span class="line"></span><br><span class="line">yarn web 在浏览器中打开</span><br><span class="line"></span><br><span class="line">webstorm可通过配置启动项启动vscode客户端，由于我使用的是vscode编辑器，目前是通过双击打开vscode源码目录下的scripts/code.bat文件打开客户端，mac用户可双击scripts/code.sh文件</span><br></pre></td></tr></tbody></table></figure>

<h2 id="vscode基本认识"><a href="#vscode基本认识" class="headerlink" title="vscode基本认识"></a>vscode基本认识</h2><h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><p><img src="/images/uploads/sites/2/2020/11/QQ%E6%88%AA%E5%9B%BE20201111100348.png"> - 使用 Web 技术来编写 UI，用 chrome 浏览器内核来运行 - 使用 NodeJS 来操作文件系统和发起网络请求 - 使用 NodeJS C++ Addon 去调用操作系统的 native API</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── azure-pipelines.yml</span><br><span class="line">├── build/</span><br><span class="line">├── extensions/</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── out/</span><br><span class="line">├── package.json</span><br><span class="line">├── product.json</span><br><span class="line">├── resources/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   └── vs</span><br><span class="line">│       ├── base/</span><br><span class="line">│       ├── code/</span><br><span class="line">│            ├── browser/</span><br><span class="line">│                 ├── workbench.ts</span><br><span class="line">│                 └── workbench/workbench.html</span><br><span class="line">│            ├── electron-browser/</span><br><span class="line">│                 ├── workbench.js</span><br><span class="line">│                 └── workbench/workbench.html</span><br><span class="line">│            └── electron-main/</span><br><span class="line">│                 ├── main.ts</span><br><span class="line">│                 └── window.ts</span><br><span class="line">│       ├── editor/</span><br><span class="line">│       ├── platform/</span><br><span class="line">│       ├── server/</span><br><span class="line">│       └── workbench/</span><br><span class="line">└── test/ //放的是各种自动化、冒烟、UI 测试脚本，这里值得学习和研究下</span><br></pre></td></tr></tbody></table></figure>

<p>目录解析 - azure-pipelines.yml，它是一个 CI/CD 的配置，自动测试、构建、打包 - build/，这里面放的是 VS Code 项目的构建工具，相对来说还是比较复杂的，主要是因为它顾及了 Linux/Mac/Windows 三个平台 - extensions/，VS Code 的内置模块，包含各种语言高亮的 LSP 相关模块 - gulpfile.js，构建脚本，暂时不用细看，可以关注 package.json 的 scripts，里面放着一些程序的快捷启动方式，而且针对内存溢出做了防御，如 –max_old_space_size=4095 - out/，构建的结果都放在这个目录下 - package.json，需要着重看看 main 和 scripts 两个字段 - product.json，如果你想根据 VS Code 进行二次开发，建立自己的品牌，建议搞懂这个文件，因为你需要修改它 - resource/，打包构建生成安装包（exe/dmg/deb 等）的时候需要依赖的额外资源 - scripts/，开发过程各种会用到的脚本，用的比较多的可能是 ./scripts/code.sh - test/，放的是各种自动化、冒烟、UI 测试脚本，这里值得学习和研究下 - src/，核心源码</p>
<h3 id="结构细分"><a href="#结构细分" class="headerlink" title="结构细分"></a>结构细分</h3><p>一下内容均摘抄至<a class="link" href="https://zhuanlan.zhihu.com/p/96041706" title="从 VSCode 看大型 IDE 技术架构">《从 VSCode 看大型 IDE 技术架构》<i class="fas fa-external-link-alt"></i></a>。 1. 隔离内核 (src) 与插件 (extensions)，内核分层模块化</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">/src/vs：分层和模块化的 core</span><br><span class="line">/src/vs/base: 通用的公共方法和公共视图组件</span><br><span class="line">/src/vs/code: VSCode 应用主入口</span><br><span class="line">/src/vs/platform：可被依赖注入的各种纯服务</span><br><span class="line">/src/vs/editor: 文本编辑器</span><br><span class="line">/src/vs/workbench：整体视图框架</span><br><span class="line">/src/typings: 公共基础类型</span><br><span class="line">/extensions：内置插件</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>每层按环境隔离 内核里面每一层代码都会遵守 electron 规范，按不同环境细分文件夹:</li>
</ol>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">common: 公共的 js 方法，在哪里都可以运行的</span><br><span class="line">browser: 只使用浏览器 API 的代码，可以调用 common</span><br><span class="line">node: 只使用 NodeJS API 的代码，可以调用 common</span><br><span class="line">electron-browser: 使用 electron 渲染线程和浏览器 API 的代码，可以调用 common，browser，node</span><br><span class="line">electron-main: 使用 electron 主线程和 NodeJS API 的代码，可以调用 common， node</span><br><span class="line">test: 测试代码</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>内核代码本身也采用扩展机制: Contrib 可以看到 /src/vs/workbench/contrib 这个目录下存放着非常多的 VSCode 的小的功能单元：</li>
</ol>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">├── backup</span><br><span class="line">├── callHierarchy</span><br><span class="line">├── cli</span><br><span class="line">├── codeActions</span><br><span class="line">├── codeEditor</span><br><span class="line">├── comments</span><br><span class="line">├── configExporter</span><br><span class="line">├── customEditor</span><br><span class="line">├── debug</span><br><span class="line">├── emmet</span><br><span class="line">├──....中间省略无数....</span><br><span class="line">├── watermark</span><br><span class="line">├── webview</span><br><span class="line">└── welcome</span><br></pre></td></tr></tbody></table></figure>

<p>Contrib 有一些特点：</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">Contrib 目录下的所有代码不允许依赖任何本文件夹之外的文件</span><br><span class="line">Contrib 主要是使用 Core 暴露的一些扩展点来做事情</span><br><span class="line">每一个 Contrib 如果要对外暴露，将API 在一个出口文件里面导出 eg: contrib/search/common/search.ts</span><br><span class="line">一个 Contrib 如果要和另一个 Contrib 发生调用，不允许使用除了出口 API 文件之外的其它文件</span><br><span class="line">接上一条，即使 Contrib 事实上可以调用另一个 Contrib 的出口 API，也要审慎的考虑并尽量避免两个 Contrib 互相依赖</span><br></pre></td></tr></tbody></table></figure>

<h2 id="vscode启动流程"><a href="#vscode启动流程" class="headerlink" title="vscode启动流程"></a>vscode启动流程</h2><p>具体可参照<a class="link" href="https://zhuanlan.zhihu.com/p/96041706" title="从 VSCode 看大型 IDE 技术架构">《从 VSCode 看大型 IDE 技术架构》<i class="fas fa-external-link-alt"></i></a>关于启动流程的精简链路解读。 <strong>简要描述：</strong> - 入口是 src/main.js - 主进程（Main Process） 的实际调用路径是: <code>main.js -&gt; vs/code/electron-main/main.ts -&gt; vs/code/electron-main/window.ts</code> 在 <code>window.ts</code> 启动了一个<code>BrowserWindow</code> 加载了 <code>vs/code/electron-browser/workbench/workbench.html</code> - 渲染进程（Renderer Process）的实际路径是： <code>vs/code/electron-browser/workbench/workbench.html -&gt; vs/code/electron-browser/workbench/workbench.js</code> 核心逻辑在 <code>workbench.js</code> 中，而 src 下还有一个核心目录 <code>browser</code>，它是 Web 版本的启动入口</p>
<h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3><h2 id="vscode代码调试"><a href="#vscode代码调试" class="headerlink" title="vscode代码调试"></a>vscode代码调试</h2><h2 id="vscode导航栏调试分析"><a href="#vscode导航栏调试分析" class="headerlink" title="vscode导航栏调试分析"></a>vscode导航栏调试分析</h2></body></html>]]></content>
      <categories>
        <category>vscode源码解读</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>vscode源码组织</title>
    <url>/2020/12/04/vscode-source-organization/</url>
    <content><![CDATA[<html><head></head><body><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>vscode由一个分层的、模块化的<code>core</code>组成（即src/vs目录），它可以通过<code>extensions</code>机制进行扩展。<code>extensions</code>运行在称为<code>extension host</code>的单独进程中,通过使用<code>extensions API</code>去实现。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="根目录结构"><a href="#根目录结构" class="headerlink" title="根目录结构"></a>根目录结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">├── build       # gulp编译构建脚本 </span><br><span class="line">├── extensions  # 内置插件 </span><br><span class="line">├── out         # 编译输出目录</span><br><span class="line">├── resources     # 平台相关静态资源，图标等 </span><br><span class="line">├── scripts       # 工具脚本，开发/测试 </span><br><span class="line">├── src           # 源码目录 </span><br><span class="line">└── test          # 测试套件</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="src下文件目录结构"><a href="#src下文件目录结构" class="headerlink" title="src下文件目录结构"></a>src下文件目录结构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">├── bootstrap-amd.js    # 子进程实际入口</span><br><span class="line">├── bootstrap-fork.js   #</span><br><span class="line">├── bootstrap-window.js #</span><br><span class="line">├── bootstrap.js        # 子进程环境初始化</span><br><span class="line">├── buildfile.js        # 构建config</span><br><span class="line">├── cli.js              # CLI入口</span><br><span class="line">├── main.js             # 主进程入口</span><br><span class="line">├── paths.js            # AppDataPath与DefaultUserDataPath</span><br><span class="line">├── typings</span><br><span class="line">│          └── xxx.d.ts        # ts类型声明</span><br><span class="line">└── vs   </span><br><span class="line">    ├── base            # 定义基础的工具方法和基础的 DOM UI 控件   </span><br><span class="line">        │   ├── browser     # 基础UI组件，DOM操作、交互事件、DnD等  </span><br><span class="line">        │   ├── common      # diff描述，markdown解析器，worker协议，各种工具函数     </span><br><span class="line">        │   ├── node        # Node工具函数   </span><br><span class="line">        │   ├── parts       # IPC协议（Electron、Node），quickopen、tree组件   </span><br><span class="line">        │   ├── test        # base单测用例    </span><br><span class="line">        │   └── worker      # Worker factory 和 main Worker（运行IDE Core：Monaco）</span><br><span class="line">    ├── code            # VSCode Electron 应用的入口，包括 Electron 的主进程脚本入口   </span><br><span class="line">        │   ├── electron-browser # 需要 Electron 渲染器处理API的源代码（可以使用 common, browser, node）</span><br><span class="line">        │   ├── electron-main    # 需要Electron主进程API的源代码（可以使用 common, node）   </span><br><span class="line">        │   ├── node        # 需要Electron主进程API的源代码（可以使用 common, node）  </span><br><span class="line">        │   ├── test  </span><br><span class="line">        │   └── code.main.ts </span><br><span class="line"></span><br><span class="line">    ├── editor   # Monaco Editor 代码编辑器：其中包含单独打包发布的 Monaco Editor 和只能在 VSCode 的使用的部分    </span><br><span class="line">        │   ├── browser     # 代码编辑器核心   </span><br><span class="line">        │   ├── common      # 代码编辑器核心   </span><br><span class="line">        │   ├── contrib     # vscode 与独立 IDE共享的代码 </span><br><span class="line">        │   ├── standalone  # 独立 IDE 独有的代码 </span><br><span class="line">        │   ├── test    │   ├── editor.all.ts  </span><br><span class="line">        │   ├── editor.api.ts   </span><br><span class="line">        │   ├── editor.main.ts </span><br><span class="line">        │   └── editor.worker.ts  </span><br><span class="line">    ├── platform        # 依赖注入的实现和 VSCode 使用的基础服务 Services   </span><br><span class="line">    ├── workbench       # VSCode 桌面应用程序工作台的实现 </span><br><span class="line">    ├── buildunit.json   </span><br><span class="line">    ├── css.build.js    # 用于插件构建的CSS loader   </span><br><span class="line">    ├── css.js          # CSS loader   </span><br><span class="line">    ├── loader.js       # AMD loader（用于异步加载AMD模块，类似于require.js） </span><br><span class="line">    ├── nls.build.js    # 用于插件构建的 NLS loader   </span><br><span class="line">    └── nls.js          # NLS（National Language Support）多语言loader   </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p><code>core</code>分为以下几层：</p>
<ul>
<li><code>base</code>: 提供常规实用程序和用户界面构建块</li>
<li><code>platform</code>: 为VS Code定义服务注入支持和基本服务</li>
<li><code>editor</code>: “ Monaco”编辑器可作为单独的可下载组件使用</li>
<li><code>workbench</code>: 托管“Monaco”编辑器，并提供“视口”的框架，例如资源管理器，状态栏或菜单栏，并利用Electron来实现VS Code桌面应用程序。</li>
</ul>
<h2 id="目标环境"><a href="#目标环境" class="headerlink" title="目标环境"></a>目标环境</h2><p>VS Code的核心完全采用TypeScript实现。在每一层内部，代码都是由目标运行时环境组成的。这样可以确保仅使用运行时特定的API。在代码中，我们对目标环境做以下区分：</p>
<ul>
<li><p><code>common</code>目录存放的是：仅需要基本的JavaScript API，并且可以运行在其他目标环境中的源代码</p>
</li>
<li><p><code>browser</code>目录存放的是：需要访问browserAPI如进行DOM操作的源代码。 可以引入<code>common</code>目录下的源码</p>
</li>
<li><p><code>node</code>目录存放的是：引入nodejs API的源码。 可以引入<code>common</code>目录下的源码</p>
</li>
<li><p><code>electron-sandbox</code>目录存放的是：即需要访问browserAPI如进行DOM操作和要求浏览器API，也需要操作一小部分ElectronAPI用来和Electron主进程进行通信的源代码。 可以使用<code>common</code>、<code>browser</code>、<code>electron-sandbox</code>目录下的源码。</p>
</li>
<li><p><code>electro-browser</code>目录存放的是：引入了electron 渲染进程API的源码。 可以使用<code>common</code>、<code>browser</code>、<code>node</code>目录文件。</p>
</li>
<li><p><code>electron-main</code>目录存放的是：引入了electron主进程API的源码。 可以使用<code>common</code>、<code>node</code>目录源码。</p>
</li>
</ul>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>源码是通过<code>services</code>组成的，<code>services</code>更多的被定义在<code>platform</code>层中。<code>Services</code>通过<code>construction injection</code>（构造函数注入）的方式得到对应的客户端（clients）。 <code>service</code>定义分为两部分： （1）（<code>service</code>）服务的接口（<code>interface</code>） （2）服务(<code>service</code>)标识符(<code>identifier</code>) 服务标识符是必需的，因为<code>TypeScript</code>不使用标称类型而是结构性类型。 服务标识符是一种修饰器（针对<code>ES7</code>提出），并且应与服务接口具有相同的名称。 声明服务依赖关系是通过在构造函数参数中添加相应的修饰来实现的。 在下面的代码段中，<code>@ IModelService</code>是服务标识符修饰符，而<code>IModelService</code>是此参数的（可选）类型注释。 如果依赖项是可选的，请使用<code>@optional</code>装饰，否则实例化服务将引发错误。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Client {</span><br><span class="line">  constructor(</span><br><span class="line">    @IModelService modelService: IModelService, </span><br><span class="line">    @optional(IEditorService) editorService: IEditorService</span><br><span class="line">  ) {</span><br><span class="line">    // use services</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用实例化服务为服务使用者创建实例，例如<code>InstantiationService.createInstance（Client）</code>。 通常，当您注册为贡献内容（例如<code>Viewle</code>或<code>Language</code>）时，会为您完成此操作。</p>
<h2 id="VS-Code-Editor的源组织"><a href="#VS-Code-Editor的源组织" class="headerlink" title="VS Code Editor的源组织"></a>VS Code Editor的源组织</h2><ul>
<li><code>vs/editor</code>文件夹不应该有任何<code>node</code>或<code>electron-browser</code>依赖关系。</li>
<li><code>vs/editor/common</code>和<code>vs/editor/browser</code>-代码编辑器核心（若没有这些则编辑器没有任何意义）。</li>
<li><code>vs/editor/contrib</code>-VS Code和独立编辑器中附带的代码编辑器贡献。依照<code>browser</code>惯例，编辑器在缺失相关<code>contrib</code>的情况下，会导致相应功能被删除。</li>
<li><code>vs/editor/standalone</code>-仅独立编辑器附带的代码。不存在别的依赖。</li>
<li><code>vs/workbench/contrib/codeEditor</code> -VS Code中附带的代码编辑器贡献。</li>
</ul>
<h2 id="工作台贡献"><a href="#工作台贡献" class="headerlink" title="工作台贡献"></a>工作台贡献</h2><p>VS Code工作台（<code>vs/workbench</code>）由许多内容组成，可提供丰富的开发经验。示例包括全文搜索，集成的git和debug。从本质上讲，工作台并不直接依赖于所有这些贡献。相反，我们使用内部（而不是真正的扩展API）机制将这些<code>contrib</code>贡献给工作台。 贡献给工作台的所有贡献都存放在该<code>vs/workbench/contrib</code>文件夹中。此文件夹中有一些规则：</p>
<ul>
<li><code>vs/workbench/contrib</code>文件夹内部代码与外界没有任何依赖关系</li>
<li>每个贡献都应从单个文件中公开其内部API（例如<code>vs/workbench/contrib/search/common/search.ts</code>）</li>
<li>一个贡献可以取决于另一个贡献的内部API（例如git贡献可能取决于 <code>vs/workbench/contrib/search/common/search.ts</code>）</li>
<li>一个贡献永远都不能进入另一个贡献的内部（内部是贡献文件中不存在于单个公共API文件中的其他内容）</li>
<li>在让一个贡献依赖于另一个贡献之前要三思：这是否确实需要，是否有意义？是否可以通过使用工作台的可扩展性来避免这种依赖性呢？</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>vscode源码解读</category>
      </categories>
  </entry>
  <entry>
    <title>工作日志 2023/3/30</title>
    <url>/2023/03/30/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%972023:3:30/</url>
    <content><![CDATA[<html><head></head><body><p>今天依然处理了一整天的vitepress项目构建问题。</p>
<p>从昨天负责编写公共库的同事反馈文档项目无法构建起，我已经排查并解决了一系列的问题，其中主要是：</p>
<p>（1）构建所依赖的外部包版本问题；</p>
<p>（2）vitepress 服务端渲染（SSR）兼容问题</p>
<p>（3）多工作区项目之间的引用问题</p>
<p>对于问题（1）构建所依赖的外部包版本问题</p>
<p>最终的解决方案是比对了ElementPlus文档项目（我们的文档项目，是基于elementPlus文档项目的实现）中使用的<strong>包版本</strong>，跟其保持一致。问题出在我们的文档项目所使用的vite依赖包高于elementPlus</p>
<p>对于问题（2）</p>
<p>原因是文档项目所引入的内部人员开发的公共依赖库存在对SSR不友好操作，比如在文档导入时即操作了dom，在不好修改所依赖的对SSR不友好三方库的情况下，vitepress官方提供了一些<strong>ssr兼容</strong>方案，其中一些方案需要升级vitepress版本，由于改动较大，临时使用<strong>动态导入三依赖包</strong>的方案。</p>
<p>对于问题（3）</p>
<p>虽然目前我们的文档项目和另外的几个公共库项目放在同一级目录下，但并未采用多工作区的源码管理策略(吐槽：模块引用混乱，构建繁琐，建议架构人员学习下element的源码管理，好好设计下源码结构)；</p>
<p>文档项目所参与的文档及Demo编写人员起初是通过设置相对路径别名引用了公共组件库源文件，这种引用方案导致构建文档时会连带组件库源文件的构建，难以实现自动化部署，所以需要全部替换为引入外部依赖包的方式；</p>
<p>（3.1）由于vitepress在构建期间使用vue的服务端渲染功能在node.js中预渲染应用程序，我们的web公共组件库至少需要构建为es、cjs两种格式的包文件，此处又了解了组件库构建配置、包文件路径映射等内容</p>
<p>到此，三个问题解决完毕后，我的文档项目已成功构建并配合运维人员实现了自动化部署工作。</p>
<p><strong>后续问题</strong></p>
<p>在顺手配置了公共组件库以构建出SSR兼容的包文件后，出现了两个问题：</p>
<p>（1）负责编写公共组件库的同事反馈在文档启动开发服务运行项目后，动态导入的内容为undefined，</p>
<p>（2）在业务项目中使用公共组件库的同事反馈构建的包抛出很多错误</p>
<p>对于问题（1）</p>
<p>我启动文档本地服务后，确实发现了此问题，我联想到是包文件映射的问题，因为动态导入时es语法，只有基于es语法的包文件才能正确导入，若导入的是其他包文件，大概率会产生这个错误，检查公共组件库的package.json文件后，exports.import映射的路径非es module包文件，修正后，打包，手动copy到docs项目中的node_modules目录下后，重新运行项目，发现错误仍然存在，在又尝试了一次后我陷入了迷惑；后来我再构建好的文件中埋点，运行测试发现并未执行我的新增代码，我终于了解到是包缓存问题，我又了解到了vite的依赖预构建机制，在手动删除vite缓存后，再次执行，结果是成功导入了正确的es包文件，问题解决了。</p>
<p>对于问题（2）</p>
<p>我运行了业务项目，看到了抛出的问题，经过分析很快就发现是依赖包版本不一致导致的问题。原因如下：</p>
<p>我们的公共组件库引用的three包的版本是0.125.1，而业务项目中也引入了three包，版本是0.150，当业务项目中用yarn去安装依赖的时候，由于依赖包版本不一致，公共组件库和业务项目在各自目录下装了不同版本的three依赖包，导致了一些ts类型报错。</p>
</body></html>]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
  </entry>
  <entry>
    <title>记录一次rebase操作</title>
    <url>/2021/04/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1rebase%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<html><head></head><body><h2 id="git-合并方法介绍"><a href="#git-合并方法介绍" class="headerlink" title="git 合并方法介绍"></a>git 合并方法介绍</h2><h3 id="方法一：git-merge"><a href="#方法一：git-merge" class="headerlink" title="方法一：git merge"></a>方法一：git merge</h3><p>把两个父节点及其提交记录包含起来生成一个新的节点</p>
<h3 id="方法二：git-rebase"><a href="#方法二：git-rebase" class="headerlink" title="方法二：git rebase"></a>方法二：git rebase</h3><p>复制被rebase的提交记录到当前分支</p>
<h2 id="记录一次rebase操作"><a href="#记录一次rebase操作" class="headerlink" title="记录一次rebase操作"></a>记录一次rebase操作</h2><blockquote>
<p>我要进行合并啦，记录下问题</p>
</blockquote>
<h3 id="步骤一：合并之前分支更新到最新"><a href="#步骤一：合并之前分支更新到最新" class="headerlink" title="步骤一：合并之前分支更新到最新"></a>步骤一：合并之前分支更新到最新</h3><p>dev分支 <img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423152110.png"> add-account-view分支 <img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423152236-1.png"></p>
<h3 id="步骤二：login-rebase-dev"><a href="#步骤二：login-rebase-dev" class="headerlink" title="步骤二：login rebase dev"></a>步骤二：login rebase dev</h3><p><img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423152606.png"> <strong>遇到冲突</strong></p>
<h3 id="步骤三：解决冲突后，git-add，然后-rebase-–continue"><a href="#步骤三：解决冲突后，git-add，然后-rebase-–continue" class="headerlink" title="步骤三：解决冲突后，git add，然后 rebase –continue"></a>步骤三：解决冲突后，git add，然后 rebase –continue</h3><p><img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423152920.png"> 若依然存在冲突，则<strong>重复步骤三</strong>，冲突解决完毕后，结果如下： <img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423153056.png"></p>
<blockquote>
<p><em>错误提示</em> 当前add-account-view的状态为，需要拉取39个提交，以及推送67个提交， 按理来说我们正确的合并了dev分支，并解决了相应冲突。 那么问题为什么会出现呢？以及怎么解决这个问题呢？</p>
</blockquote>
<h4 id="若根据git状态拉取，则需继续解决冲突，此时冲突跟之前遇到的一样"><a href="#若根据git状态拉取，则需继续解决冲突，此时冲突跟之前遇到的一样" class="headerlink" title="若根据git状态拉取，则需继续解决冲突，此时冲突跟之前遇到的一样"></a>若根据git状态拉取，则需继续解决冲突，此时冲突跟之前遇到的一样</h4><p><img src="/images/uploads/sites/2/2021/04/I1VLL_8Q5YAQM@44EO.png"></p>
<h4 id="继续解决重复冲突，完毕后如下"><a href="#继续解决重复冲突，完毕后如下" class="headerlink" title="继续解决重复冲突，完毕后如下"></a>继续解决重复冲突，完毕后如下</h4><p><img src="/images/uploads/sites/2/2021/04/image-20210423154134815.png"></p>
<h4 id="回到dev分支，继续rebase"><a href="#回到dev分支，继续rebase" class="headerlink" title="回到dev分支，继续rebase"></a>回到dev分支，继续rebase</h4><p>依然存在同样冲突： <img src="/images/uploads/sites/2/2021/04/I1VLL_8Q5YAQM@44EO-2.png"> <em>继续解决冲突，完毕，依然需要pull，重新解决冲突，此时问题跟在add-account-view分支上问题一模一样。</em></p>
<blockquote>
<p>通过在网上查找资料，参考别人操作： 得知，正确步骤为： <img src="/images/uploads/sites/2/2021/04/ICXI9IHJVCLZE6OA0SG8.png"></p>
</blockquote>
<h3 id="步骤四-直接执行-git-push-–force"><a href="#步骤四-直接执行-git-push-–force" class="headerlink" title="步骤四 直接执行 git push –force"></a>步骤四 直接执行 git push –force</h3><p><img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423154746.png"></p>
<h3 id="步骤五-成功rebase"><a href="#步骤五-成功rebase" class="headerlink" title="步骤五 成功rebase"></a>步骤五 成功rebase</h3><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423155042.png"></p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><ol>
<li>rebase之后，相对远程分支而言，本地基底发生了变化，引发了需要pull一下的提示</li>
<li>如果确保没问题是可以强制 push的</li>
</ol>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>相当于变基之后本地提交是： C1，C2’，C3’,C4,C5;（C2‘ C3’为目标合并分支的提交记录） 远程提交时： C1，C4，C5</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>本地提交的前三个提交跟远程的前三个提交不一致，就会提示拉取代码，此时拉取代码会把C4，C5再拉取一下</strong> 如果拉取就相当于跟我新合并的代码又冲突，还得解决一次，而且<strong>git pull默认是merge</strong>合并 <strong>git pull之后，就相当于又merge合并了一次：</strong> 把提交记录变成了： C1，C4，C5，C2’,C3’ ,C4,C5,可能后边还有其他的合并提交 同名的后一个只是副本这种，还会造成其他的合并提交 <img src="/images/uploads/sites/2/2021/04/QQ%E5%9B%BE%E7%89%8720210423160822.png"> 先强推下account分支，然后dev再rebase account分支，不然如果同时有其他同事也在提交，那就会被覆盖掉。</p>
</body></html>]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
</search>
